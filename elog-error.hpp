// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace cfam
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace cfam
} // namespace sdbusplus

namespace sdbusplus
{
namespace cfam
{
namespace Error
{
    struct OpenFailure;
} // namespace Error
} // namespace cfam
} // namespace sdbusplus

namespace sdbusplus
{
namespace cfam
{
namespace Error
{
    struct SeekFailure;
} // namespace Error
} // namespace cfam
} // namespace sdbusplus

namespace sdbusplus
{
namespace cfam
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace cfam
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace cfam
{
namespace _OpenFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Path
{
    static constexpr auto str = "Path=%s";
    static constexpr auto str_short = "Path";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr Path(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _OpenFailure

struct OpenFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "cfam.OpenFailure";
    static constexpr auto errDesc = "Failed to open the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _OpenFailure::ERRNO;
    using Path = _OpenFailure::Path;
    using metadata_types = std::tuple<ERRNO, Path>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace cfam


namespace details
{

template <>
struct map_exception_type<sdbusplus::cfam::Error::OpenFailure>
{
    using type = cfam::OpenFailure;
};

}

namespace cfam
{
namespace _ReadFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _ReadFailure

struct ReadFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "cfam.ReadFailure";
    static constexpr auto errDesc = "Failed to read from the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _ReadFailure::ERRNO;
    using Address = _ReadFailure::Address;
    using Processor = _ReadFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace cfam


namespace details
{

template <>
struct map_exception_type<sdbusplus::cfam::Error::ReadFailure>
{
    using type = cfam::ReadFailure;
};

}

namespace cfam
{
namespace _WriteFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _WriteFailure

struct WriteFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "cfam.WriteFailure";
    static constexpr auto errDesc = "Failed to open the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _WriteFailure::ERRNO;
    using Address = _WriteFailure::Address;
    using Processor = _WriteFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace cfam


namespace details
{

template <>
struct map_exception_type<sdbusplus::cfam::Error::WriteFailure>
{
    using type = cfam::WriteFailure;
};

}

namespace cfam
{
namespace _SeekFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _SeekFailure

struct SeekFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "cfam.SeekFailure";
    static constexpr auto errDesc = "Failed to seek on the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _SeekFailure::ERRNO;
    using Address = _SeekFailure::Address;
    using Processor = _SeekFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace cfam


namespace details
{

template <>
struct map_exception_type<sdbusplus::cfam::Error::SeekFailure>
{
    using type = cfam::SeekFailure;
};

}


} // namespace logging

} // namespace phosphor
