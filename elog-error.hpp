// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace Error
{
    struct OpenFailure;
} // namespace Error
} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace Error
{
    struct SeekFailure;
} // namespace Error
} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace _OpenFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Path
{
    static constexpr auto str = "Path=%s";
    static constexpr auto str_short = "Path";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr Path(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _OpenFailure

struct OpenFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.Proc.Cfam.OpenFailure";
    static constexpr auto errDesc = "Failed to open the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _OpenFailure::ERRNO;
    using Path = _OpenFailure::Path;
    using metadata_types = std::tuple<ERRNO, Path>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::Cfam::Error::OpenFailure>
{
    using type = org::open_power::Proc::Cfam::OpenFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace _ReadFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _ReadFailure

struct ReadFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.Proc.Cfam.ReadFailure";
    static constexpr auto errDesc = "Failed to read from the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _ReadFailure::ERRNO;
    using Address = _ReadFailure::Address;
    using Processor = _ReadFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::Cfam::Error::ReadFailure>
{
    using type = org::open_power::Proc::Cfam::ReadFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace _WriteFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _WriteFailure

struct WriteFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.Proc.Cfam.WriteFailure";
    static constexpr auto errDesc = "Failed to open the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _WriteFailure::ERRNO;
    using Address = _WriteFailure::Address;
    using Processor = _WriteFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::Cfam::Error::WriteFailure>
{
    using type = org::open_power::Proc::Cfam::WriteFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace Cfam
{
namespace _SeekFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Address
{
    static constexpr auto str = "Address=0x%0x";
    static constexpr auto str_short = "Address";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Address(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct Processor
{
    static constexpr auto str = "Processor=%d";
    static constexpr auto str_short = "Processor";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr Processor(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _SeekFailure

struct SeekFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "org.open_power.Proc.Cfam.SeekFailure";
    static constexpr auto errDesc = "Failed to seek on the device.";
    static constexpr auto L = level::INFO;
    using ERRNO = _SeekFailure::ERRNO;
    using Address = _SeekFailure::Address;
    using Processor = _SeekFailure::Processor;
    using metadata_types = std::tuple<ERRNO, Address, Processor>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Cfam
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::Cfam::Error::SeekFailure>
{
    using type = org::open_power::Proc::Cfam::SeekFailure;
};

}


} // namespace logging

} // namespace phosphor
