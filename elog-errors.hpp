// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct Timeout;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct GPIO;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct InvalidArgument;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct IIC;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct Inventory;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace Error
{
    struct SeekFailure;
} // namespace Error
} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Open;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace Error
{
    struct SlaveDetectionFailure;
} // namespace Error
} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Error
{
    struct InternalFailure;
} // namespace Error
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct Device;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace Error
{
    struct OpenFailure;
} // namespace Error
} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Seek;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace Error
{
    struct MasterDetectionFailure;
} // namespace Error
} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace Error
{
    struct ReadFailure;
} // namespace Error
} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace Error
{
    struct IPMISensor;
} // namespace Error
} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace Error
{
    struct WriteFailure;
} // namespace Error
} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace Error
{
    struct Write;
} // namespace Error
} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace _OpenFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _OpenFailure

struct OpenFailure
{
    static constexpr auto L = level::ERR;
    using ERRNO = _OpenFailure::ERRNO;
    using PATH = _OpenFailure::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;

};

} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::CFAM::Error::OpenFailure>
{
    using type = org::open_power::Proc::CFAM::OpenFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace _SeekFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct ADDRESS
{
    static constexpr auto str = "ADDRESS=0x%0x";
    static constexpr auto str_short = "ADDRESS";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr ADDRESS(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct OFFSET
{
    static constexpr auto str = "OFFSET=%ll";
    static constexpr auto str_short = "OFFSET";
    using type = std::tuple<std::decay_t<decltype(str)>,int64_t>;
    explicit constexpr OFFSET(int64_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _SeekFailure

struct SeekFailure
{
    static constexpr auto L = level::ERR;
    using ERRNO = _SeekFailure::ERRNO;
    using ADDRESS = _SeekFailure::ADDRESS;
    using OFFSET = _SeekFailure::OFFSET;
    using PATH = _SeekFailure::PATH;
    using metadata_types = std::tuple<ERRNO, ADDRESS, OFFSET, PATH>;

};

} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::CFAM::Error::SeekFailure>
{
    using type = org::open_power::Proc::CFAM::SeekFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Open
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Open

struct Open
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Open::ERRNO;
    using PATH = _Open::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Open>
{
    using type = xyz::openbmc_project::Common::File::Open;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Seek
{

struct OFFSET
{
    static constexpr auto str = "OFFSET=%ll";
    static constexpr auto str_short = "OFFSET";
    using type = std::tuple<std::decay_t<decltype(str)>,int64_t>;
    explicit constexpr OFFSET(int64_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct WHENCE
{
    static constexpr auto str = "WHENCE=%d";
    static constexpr auto str_short = "WHENCE";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr WHENCE(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Seek

struct Seek
{
    static constexpr auto L = level::ERR;
    using OFFSET = _Seek::OFFSET;
    using WHENCE = _Seek::WHENCE;
    using ERRNO = _Seek::ERRNO;
    using PATH = _Seek::PATH;
    using metadata_types = std::tuple<OFFSET, WHENCE, ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Seek>
{
    using type = xyz::openbmc_project::Common::File::Seek;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace File
{
namespace _Write
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Write

struct Write
{
    static constexpr auto L = level::ERR;
    using ERRNO = _Write::ERRNO;
    using PATH = _Write::PATH;
    using metadata_types = std::tuple<ERRNO, PATH>;

};

} // namespace File
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::File::Error::Write>
{
    using type = xyz::openbmc_project::Common::File::Write;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _Device
{

struct CALLOUT_ERRNO
{
    static constexpr auto str = "CALLOUT_ERRNO=%d";
    static constexpr auto str_short = "CALLOUT_ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr CALLOUT_ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct CALLOUT_DEVICE_PATH
{
    static constexpr auto str = "CALLOUT_DEVICE_PATH=%s";
    static constexpr auto str_short = "CALLOUT_DEVICE_PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr CALLOUT_DEVICE_PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Device

struct Device
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = _Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = _Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::Device>
{
    using type = xyz::openbmc_project::Common::Callout::Device;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _GPIO
{

struct CALLOUT_GPIO_NUM
{
    static constexpr auto str = "CALLOUT_GPIO_NUM=%u";
    static constexpr auto str_short = "CALLOUT_GPIO_NUM";
    using type = std::tuple<std::decay_t<decltype(str)>,uint32_t>;
    explicit constexpr CALLOUT_GPIO_NUM(uint32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _GPIO

struct GPIO
{
    static constexpr auto L = level::ERR;
    using CALLOUT_GPIO_NUM = _GPIO::CALLOUT_GPIO_NUM;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_GPIO_NUM, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::GPIO>
{
    using type = xyz::openbmc_project::Common::Callout::GPIO;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _IIC
{

struct CALLOUT_IIC_BUS
{
    static constexpr auto str = "CALLOUT_IIC_BUS=%s";
    static constexpr auto str_short = "CALLOUT_IIC_BUS";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr CALLOUT_IIC_BUS(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct CALLOUT_IIC_ADDR
{
    static constexpr auto str = "CALLOUT_IIC_ADDR=0x%hx";
    static constexpr auto str_short = "CALLOUT_IIC_ADDR";
    using type = std::tuple<std::decay_t<decltype(str)>,uint16_t>;
    explicit constexpr CALLOUT_IIC_ADDR(uint16_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _IIC

struct IIC
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IIC_BUS = _IIC::CALLOUT_IIC_BUS;
    using CALLOUT_IIC_ADDR = _IIC::CALLOUT_IIC_ADDR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_IIC_BUS, CALLOUT_IIC_ADDR, CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::IIC>
{
    using type = xyz::openbmc_project::Common::Callout::IIC;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _Inventory
{

struct CALLOUT_INVENTORY_PATH
{
    static constexpr auto str = "CALLOUT_INVENTORY_PATH=%s";
    static constexpr auto str_short = "CALLOUT_INVENTORY_PATH";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr CALLOUT_INVENTORY_PATH(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Inventory

struct Inventory
{
    static constexpr auto L = level::ERR;
    using CALLOUT_INVENTORY_PATH = _Inventory::CALLOUT_INVENTORY_PATH;
    using metadata_types = std::tuple<CALLOUT_INVENTORY_PATH>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::Inventory>
{
    using type = xyz::openbmc_project::Common::Callout::Inventory;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Callout
{
namespace _IPMISensor
{

struct CALLOUT_IPMI_SENSOR_NUM
{
    static constexpr auto str = "CALLOUT_IPMI_SENSOR_NUM=%u";
    static constexpr auto str_short = "CALLOUT_IPMI_SENSOR_NUM";
    using type = std::tuple<std::decay_t<decltype(str)>,uint32_t>;
    explicit constexpr CALLOUT_IPMI_SENSOR_NUM(uint32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _IPMISensor

struct IPMISensor
{
    static constexpr auto L = level::ERR;
    using CALLOUT_IPMI_SENSOR_NUM = _IPMISensor::CALLOUT_IPMI_SENSOR_NUM;
    using metadata_types = std::tuple<CALLOUT_IPMI_SENSOR_NUM>;

};

} // namespace Callout
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Callout::Error::IPMISensor>
{
    using type = xyz::openbmc_project::Common::Callout::IPMISensor;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace _MasterDetectionFailure
{


}  // namespace _MasterDetectionFailure

struct MasterDetectionFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::FSI::Error::MasterDetectionFailure>
{
    using type = org::open_power::Proc::FSI::MasterDetectionFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace FSI
{
namespace _SlaveDetectionFailure
{

struct ERRNO
{
    static constexpr auto str = "ERRNO=%d";
    static constexpr auto str_short = "ERRNO";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr ERRNO(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _SlaveDetectionFailure

struct SlaveDetectionFailure
{
    static constexpr auto L = level::ERR;
    using ERRNO = _SlaveDetectionFailure::ERRNO;
    using metadata_types = std::tuple<ERRNO>;

};

} // namespace FSI
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::FSI::Error::SlaveDetectionFailure>
{
    using type = org::open_power::Proc::FSI::SlaveDetectionFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _Timeout
{

struct TIMEOUT_IN_MSEC
{
    static constexpr auto str = "TIMEOUT_IN_MSEC=%llu";
    static constexpr auto str_short = "TIMEOUT_IN_MSEC";
    using type = std::tuple<std::decay_t<decltype(str)>,uint64_t>;
    explicit constexpr TIMEOUT_IN_MSEC(uint64_t a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _Timeout

struct Timeout
{
    static constexpr auto L = level::ERR;
    using TIMEOUT_IN_MSEC = _Timeout::TIMEOUT_IN_MSEC;
    using metadata_types = std::tuple<TIMEOUT_IN_MSEC>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::Timeout>
{
    using type = xyz::openbmc_project::Common::Timeout;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _InternalFailure
{


}  // namespace _InternalFailure

struct InternalFailure
{
    static constexpr auto L = level::ERR;
    using metadata_types = std::tuple<>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure>
{
    using type = xyz::openbmc_project::Common::InternalFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace _InvalidArgument
{

struct ARGUMENT_NAME
{
    static constexpr auto str = "ARGUMENT_NAME=%s";
    static constexpr auto str_short = "ARGUMENT_NAME";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr ARGUMENT_NAME(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};
struct ARGUMENT_VALUE
{
    static constexpr auto str = "ARGUMENT_VALUE=%s";
    static constexpr auto str_short = "ARGUMENT_VALUE";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr ARGUMENT_VALUE(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _InvalidArgument

struct InvalidArgument
{
    static constexpr auto L = level::ERR;
    using ARGUMENT_NAME = _InvalidArgument::ARGUMENT_NAME;
    using ARGUMENT_VALUE = _InvalidArgument::ARGUMENT_VALUE;
    using metadata_types = std::tuple<ARGUMENT_NAME, ARGUMENT_VALUE>;

};

} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Error::InvalidArgument>
{
    using type = xyz::openbmc_project::Common::InvalidArgument;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace _ReadFailure
{


}  // namespace _ReadFailure

struct ReadFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::CFAM::Error::ReadFailure>
{
    using type = org::open_power::Proc::CFAM::ReadFailure;
};

}

namespace org
{
namespace open_power
{
namespace Proc
{
namespace CFAM
{
namespace _WriteFailure
{


}  // namespace _WriteFailure

struct WriteFailure
{
    static constexpr auto L = level::ERR;
    using CALLOUT_ERRNO = xyz::openbmc_project::Common::Callout::Device::CALLOUT_ERRNO;
    using CALLOUT_DEVICE_PATH = xyz::openbmc_project::Common::Callout::Device::CALLOUT_DEVICE_PATH;
    using metadata_types = std::tuple<CALLOUT_ERRNO, CALLOUT_DEVICE_PATH>;

};

} // namespace CFAM
} // namespace Proc
} // namespace open_power
} // namespace org


namespace details
{

template <>
struct map_exception_type<sdbusplus::org::open_power::Proc::CFAM::Error::WriteFailure>
{
    using type = org::open_power::Proc::CFAM::WriteFailure;
};

}


} // namespace logging

} // namespace phosphor
